const y='<?xml version="1.0" encoding="UTF-8"?>',S="http://www.w3.org/1999/XSL/Transform",h=(t,e)=>t.getAttribute(e),c=(t,e="")=>(n=>(n.innerText=e||"",n))(document.createElement(t));function E(t){return new DOMParser().parseFromString(y+t,"application/xml")}function b(t){const e=t.firstElementChild,n=i=>i.replaceAll("<html:","<").replaceAll("</html:","</").replaceAll(/>\s*<\/xsl:value-of>/g,"/>").replaceAll(/>\s*<\/(br|hr|img|area|base|col|embed|input|link|meta|param|source|track|wbr)>/g,"/>");if(e?.tagName==="TEMPLATE")return n(new XMLSerializer().serializeToString(e.content));const r=new XMLSerializer().serializeToString(t);return n(r.substring(r.indexOf(">")+1,r.lastIndexOf("<")))}function A(t){const e=document.createElementNS(S,"value-of");e.setAttribute("select",`//*[@slot="${t.name}"]`),t.parentNode.replaceChild(e,t)}function f(t,e,n,r){const s=((u,m,p)=>(m.append(p=c(u)),p))(e,t);return[...n].forEach(u=>s.append(r(u))),s}function T(t){return t.slot||(t.setAttribute||(t=c("span",t.textContent.replaceAll(`
`,""))),t.setAttribute("slot","")),t}export function Json2Xml(t,e){if(typeof t=="string")return t;const n=typeof e!="string";if(t instanceof Array)return n&&(e="array"),"<"+e+">"+t.map(function(s){return Json2Xml(s,e)}).join()+"</"+e+">";n&&(e="r"),e=e.replace(/[^a-z0-9\-]/gi,"_");var r={},i=["<"+e+" "];for(let s in t)typeof t[s]=="object"?r[s]=t[s]:i.push(s.replace(/[^a-z0-9\-]/gi,"_")+'="'+t[s].toString().replace(/&/gi,"&#38;")+'"');if(r){i.push(">");for(let s in r)i.push(Json2Xml(r[s],s));i.push("</"+e+">")}else i.push("/>");return i.join(`
`)}function N(t,e,n){const i=typeof n=="string"?c(e,n):document.adoptNode(E(Json2Xml(n,e)).documentElement);[...t.children].filter(s=>s.localName===e).map(s=>s.remove()),t.append(i)}export class CustomElement extends HTMLElement{constructor(){super(),[...this.templateNode.querySelectorAll("slot")].forEach(A);const e=new XSLTProcessor;e.importStylesheet(this.xslt);const n=h(this,"tag"),r=this,i=[...this.templateNode.querySelectorAll("[slice]")].map(s=>h(s,"slice"));n&&window.customElements.define(n,class extends HTMLElement{constructor(){super();const s=c("div");f(s,"payload",this.childNodes,T),f(s,"attributes",this.attributes,l=>c(l.nodeName,l.value)),f(s,"dataset",Object.keys(this.dataset),l=>c(l,this.dataset[l]));const u=f(s,"slice",i,l=>c(l,""));this.xml=s;const m={},p=[],x=()=>{const l={};for(let o;o=p.pop();){const a=h(o.target,"slice");l[a]||(N(u,a,o.detail),l[a]=o)}Object.keys(l).length!==0&&g()};let d;this.onSlice=l=>{l.stopPropagation?.(),p.push(l),d||(d=setTimeout(()=>{x(),d=0},10))};const g=()=>{const l=e.transformToFragment(s,document);this.innerHTML="",[...l.childNodes].forEach(o=>this.appendChild(o));for(let o of this.querySelectorAll("[slice]"))if(typeof o.sliceInit=="function"){const a=h(o,"slice");m[a]=o.sliceInit(m[a])}};g(),x()}get dce(){return r}})}get templateNode(){return this.firstElementChild?.tagName==="TEMPLATE"?this.firstElementChild.content:this}get dce(){return this}get xsltString(){return`<xsl:stylesheet version="1.0"
    xmlns:xsl="${S}">
  <xsl:output method="html" />

  <xsl:template match="/">
    <xsl:apply-templates select="//attributes"/>
  </xsl:template>
  <xsl:template match="attributes">
    ${b(this)}
  </xsl:template>

</xsl:stylesheet>`}get xslt(){return E(this.xsltString)}}window.customElements.define("custom-element",CustomElement);export default CustomElement;
//# sourceMappingURL=custom-element.js.map
