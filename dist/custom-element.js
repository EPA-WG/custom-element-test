const y='<?xml version="1.0" encoding="UTF-8"?>',S="http://www.w3.org/1999/XSL/Transform",h=(t,e)=>t.getAttribute(e),a=(t,e="")=>(n=>(n.innerText=e||"",n))(document.createElement(t));function E(t){return new DOMParser().parseFromString(y+t,"application/xml")}function T(t){const e=t.firstElementChild,n=r=>r.replaceAll("<html:","<").replaceAll("</html:","</").replaceAll(/>\s*<\/xsl:value-of>/g,"/>").replaceAll(/>\s*<\/(br|hr|img|area|base|col|embed|input|link|meta|param|source|track|wbr)>/g,"/>");if(e?.tagName==="TEMPLATE")return n(new XMLSerializer().serializeToString(e.content));const l=new XMLSerializer().serializeToString(t);return n(l.substring(l.indexOf(">")+1,l.lastIndexOf("<")))}function b(t){const e=document.createElementNS(S,"value-of");e.setAttribute("select",`//*[@slot="${t.name}"]`),t.parentNode.replaceChild(e,t)}function f(t,e,n,l){const s=((c,m,u)=>(m.append(u=a(c)),u))(e,t);return[...n].forEach(c=>s.append(l(c))),s}function A(t){return t.slot||(t.setAttribute||(t=a("span",t.textContent.replaceAll(`
`,""))),t.setAttribute("slot","")),t}export function Json2Xml(t,e){if(typeof t=="string")return t;const n=typeof e!="string";if(t instanceof Array)return n&&(e="array"),"<"+e+">"+t.map(function(s){return Json2Xml(s,e)}).join()+"</"+e+">";n&&(e="r"),e=e.replace(/[^a-z0-9\-]/gi,"_");var l={},r=["<"+e+" "];for(let s in t)typeof t[s]=="object"?l[s]=t[s]:r.push(s.replace(/[^a-z0-9\-]/gi,"_")+'="'+t[s].toString().replace(/&/gi,"&#38;")+'"');if(l){r.push(">");for(let s in l)r.push(Json2Xml(l[s],s));r.push("</"+e+">")}else r.push("/>");return r.join(`
`)}function L(t,e,n){const l=a(e),r=typeof n=="string";l.innerHTML=r?n:Json2Xml(n,e);const s=r?l:l.firstChild;[...t.children].filter(c=>c.localName===e).map(c=>c.remove()),t.append(s)}export class CustomElement extends HTMLElement{constructor(){super(),[...this.templateNode.querySelectorAll("slot")].forEach(b);const e=new XSLTProcessor;e.importStylesheet(this.xslt);const n=h(this,"tag"),l=this,r=[...this.templateNode.querySelectorAll("[slice]")].map(s=>h(s,"slice"));n&&window.customElements.define(n,class extends HTMLElement{constructor(){super();const s=a("div");f(s,"payload",this.childNodes,A),f(s,"attributes",this.attributes,i=>a(i.nodeName,i.value)),f(s,"dataset",Object.keys(this.dataset),i=>a(i,this.dataset[i]));const c=f(s,"slice",r,i=>a(i,""));this.xml=s;const m={},u=[],x=()=>{const i={};for(let o;o=u.pop();){const p=h(o.target,"slice");i[p]||(L(c,p,o.detail),i[p]=o)}Object.keys(i).length!==0&&g()};let d;this.onSlice=i=>{i.stopPropagation?.(),u.push(i),d||(d=setTimeout(()=>{x(),d=0},10))};const g=()=>{const i=e.transformToFragment(s,document);this.innerHTML="",[...i.childNodes].forEach(o=>this.appendChild(o));for(let o of this.querySelectorAll("[slice]"))if(typeof o.sliceInit=="function"){const p=h(o,"slice");m[p]=o.sliceInit(m[p])}};g(),x()}get dce(){return l}})}get templateNode(){return this.firstElementChild?.tagName==="TEMPLATE"?this.firstElementChild.content:this}get dce(){return this}get xsltString(){return`<xsl:stylesheet version="1.0"
    xmlns:xsl="${S}">
  <xsl:output method="html" />

  <xsl:template match="/">
    <xsl:apply-templates select="//attributes"/>
  </xsl:template>
  <xsl:template match="attributes">
    ${T(this)}
  </xsl:template>

</xsl:stylesheet>`}get xslt(){return E(this.xsltString)}}window.customElements.define("custom-element",CustomElement);export default CustomElement;
//# sourceMappingURL=custom-element.js.map
